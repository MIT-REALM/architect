"""Define a simulator for the satellite"""
from typing import Tuple
import time

import jax.numpy as jnp
import matplotlib.pyplot as plt

from architect.components.dynamics.linear_satellite import (
    linear_satellite_next_state_substeps,
)


def sat_simulate(
    design_params: jnp.ndarray,
    exogenous_sample: jnp.ndarray,
    time_steps: int,
    dt: float,
    substeps: int,
) -> Tuple[jnp.ndarray, jnp.ndarray]:
    """Simulate the performance of the satellite rendezvous system.

    To make this function pure, we need to pass in all sources of randomness used.

    args:
        design_params: a (6 * 3 + time_steps * (3 + 6)) array of design parameters.
            The first 6 * 3 values define a gain matrix for state-feedback control
            u = -K(x - x_planned). Each later group of 3 + 6 values is a control input
            and target state at that timestep, defining a trajectory.
        exogenous_sample: (6,) array containing initial states.
                          Can be generated by SatExogenousParameters.sample
        time_steps: the number of steps to simulate
        dt: the duration of each time step
        substeps: how many smaller updates to break this interval into
    returns:
        a tuple of
            - the state trace in a (time_steps, 6) array
            - the total expended actuation effort (mean-squared)
    """
    # Set up an array to store the results of the simulation
    state_trace = jnp.zeros((time_steps, 6)).at[0].set(exogenous_sample)
    total_effort = jnp.zeros(())

    # Reshape the design params to make them more easily accessible
    K = design_params[: 6 * 3].reshape(3, 6)
    design_params = design_params[6 * 3 :].reshape(-1, 3 + 6)
    planned_inputs = design_params[:, :3]
    planned_states = design_params[:, 3:]

    # Conduct the simulation with no actuation noise (for now)
    actuation_noise = jnp.zeros(6)
    for i in range(1, time_steps):
        # Get the planned input and state
        planned_input = planned_inputs[i - 1]
        planned_state = planned_states[i - 1]

        # Compute the control from feedback and planned
        current_state = state_trace[i - 1]
        control_input = planned_input - K @ (current_state - planned_state)
        total_effort = total_effort + (control_input ** 2).sum()

        state_trace = state_trace.at[i].set(
            linear_satellite_next_state_substeps(
                current_state, control_input, actuation_noise, dt, substeps
            )
        )

    return state_trace, total_effort / time_steps


if __name__ == "__main__":
    # Test the simulation
    t_sim = 60.0
    dt = 0.1
    substeps = 5
    T = int(t_sim // dt)
    start_state = jnp.zeros((6,)) + 1.0
    K = jnp.array(
        [
            [100.0, 0.0, 0.0, 100.0, 0.0, 0.0],
            [0.0, 100.0, 0.0, 0.0, 100.0, 0.0],
            [0.0, 0.0, 100.0, 0.0, 0.0, 100.0],
        ]
    )
    planned_trajectory = jnp.zeros((T, 9))
    design_params = jnp.concatenate((K.reshape(-1), planned_trajectory.reshape(-1)))

    # Burn-in once to activate JIT (if using)
    state_trace, effort = sat_simulate(design_params, start_state, T, dt, substeps)

    N_tests = 2
    sim_time = 0.0
    for _ in range(N_tests):
        start = time.perf_counter()
        state_trace, effort = sat_simulate(design_params, start_state, T, dt, substeps)
        end = time.perf_counter()
        sim_time += end - start

    print(f"Ran {N_tests} sims in {sim_time} s. Average {sim_time / N_tests} s")

    ax = plt.axes(projection="3d")
    ax.plot3D(state_trace[:, 0], state_trace[:, 1], state_trace[:, 2])
    ax.plot3D(0.0, 0.0, 0.0, "ko")

    plt.show()
