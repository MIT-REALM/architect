"""Define a simulator for the satellite"""
from typing import Tuple

import numpy as np
import jax.numpy as jnp
import matplotlib.pyplot as plt

from architect.components.dynamics.linear_satellite import (
    linear_satellite_next_state_substeps,
)


def sat_simulate_high_res(
    design_params: jnp.ndarray,
    exogenous_sample: jnp.ndarray,
    time_steps: int,
    dt: float,
    substeps: int,
) -> Tuple[jnp.ndarray, jnp.ndarray]:
    """Simulate the performance of the satellite rendezvous system.

    To make this function pure, we need to pass in all sources of randomness used.

    Returns all subsamples

    args:
        design_params: a (6 * 3 + time_steps * (3 + 6)) array of design parameters.
            The first 6 * 3 values define a gain matrix for state-feedback control
            u = -K(x - x_planned). Each later group of 3 + 6 values is a control input
            and target state at that timestep, defining a trajectory.
        exogenous_sample: (6,) array containing initial states.
                          Can be generated by SatExogenousParameters.sample
        time_steps: the number of steps to simulate
        dt: the duration of each time step
        substeps: how many smaller updates to break this interval into
    returns:
        a tuple of
            - the state trace in a (time_steps, 6) array
            - the total expended actuation effort (sum of 1-norm scaled by dt)
    """
    # Extract design parameters
    K = design_params[: 6 * 3].reshape(3, 6)
    planned_trajectory = design_params[6 * 3 :].reshape(-1, 3 + 6)

    # No noise for now
    actuation_noise = jnp.zeros(6)

    # Make somewhere to store the results
    state_trace = jnp.zeros((time_steps * substeps, 6))
    current_state = exogenous_sample

    for t in range(0, time_steps * substeps):
        if t % substeps == 0:
            # Get the state and control from the plan
            planned_input = planned_trajectory[int(t / substeps), :3]
            planned_state = planned_trajectory[int(t / substeps), 3:]

            # Compute the control from feedback and planned
            control_input = planned_input - K @ (current_state - planned_state)

        # Update the state
        current_state = linear_satellite_next_state_substeps(
            current_state, control_input, actuation_noise, dt / substeps, 1
        )
        state_trace = state_trace.at[t].set(current_state)

    return state_trace


if __name__ == "__main__":
    # Test the simulation
    t_sim = 200.0
    dt = 2.0
    substeps = 200
    T = int(t_sim // dt)
    start_state = jnp.array([13.0, 13.0, 3.0, 1.0, 1.0, -1.0])
    design_params = jnp.array(
        np.loadtxt(
            "logs/satellite_stl/safety_and_goal_only/design_params_opt.csv",
            delimiter=",",
        )
    )

    # Burn-in once to activate JIT (if using)
    state_trace_1 = sat_simulate_high_res(design_params, start_state, T, dt, substeps)

    ax = plt.axes(projection="3d")
    ax.plot3D(
        state_trace_1[:, 0],
        state_trace_1[:, 1],
        state_trace_1[:, 2],
        label="Chaser trajectory",
    )
    ax.plot3D([], [], [], color="grey", label="Speed-limit zone")
    ax.plot3D(start_state[0], start_state[1], start_state[2], "ks", label="Start")
    ax.plot3D(0.0, 0.0, 0.0, "ko", label="Target")
    ax.set_xlabel("$p_x$")
    ax.set_ylabel("$p_y$")
    ax.set_zlabel("$p_z$")
    ax.set_xlim([-15, 15])
    ax.set_ylim([-15, 15])
    ax.set_zlim([-15, 15])

    # Plot sphere
    u, v = np.mgrid[0 : 2 * np.pi : 100j, 0 : np.pi : 100j]
    x = 2.0 * np.cos(u) * np.sin(v)
    y = 2.0 * np.sin(u) * np.sin(v)
    z = 2.0 * np.cos(v)
    ax.plot_surface(
        x,
        y,
        z,
        edgecolor="grey",
        color="grey",
        alpha=0.1,
        zorder=0,
        rcount=6,
        ccount=6,
    )

    ax.legend()

    plt.show()
